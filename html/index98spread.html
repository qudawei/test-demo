<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>index98spread</title>
  <style>
  </style>
</head>

<body>
  <script>
    // 尾递归只存在一个调用帧中，不会出现内存溢出 
    // function factorial(n) {
    //   debugger
    //   if (n === 1) return 1;
    //   return n * factorial(n - 1);
    // }

    // factorial(5) // 120
    // function factorial(n, total) {
    //   debugger
    //   if (n === 1) return total;
    //   return factorial(n - 1, n * total);
    // }

    // factorial(5, 1) // 120

    // 第二种方法就简单多了，就是采用 ES6 的函数默认值。
    // function factorial(n, total = 1) {
    //   debugger
    //   if (n === 1) return total;
    //   return factorial(n - 1, n * total);
    // }

    // factorial(5) // 120
    Object.prototype.say="cgl"
    const arr = [
      'peach',
      'straw',
      'apple',
      'spork'
    ];
    // const stableSorting = (s1, s2) => {
    //   debugger
    //   if (s1[0] < s2[0]) return -1;
    //   return 1;
    // };

    // arr.sort(stableSorting)
    for (const key in arr) {
      if (arr.hasOwnProperty(key)) {
        // const element = arr[key];
        console.log('arr', arr[key]);
      }
      // console.log('key', key);
    }
    let obj = { foo: 123 };
    console.log(1111, Object.getOwnPropertyDescriptor(obj, 'foo') );

  </script>
</body>

</html>